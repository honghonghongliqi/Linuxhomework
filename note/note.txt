在标准I/O中，核心对象是流。所谓流，它是一个过程，所有的I/O操作都是简单的从程序的移进或移出，我们把这种字符流叫做流。标准I/O基于流的操作都是缓存文件系统。
标准I/O提供了三种类型的缓冲：
1、全缓冲。这种情况下，在填满标准I/O缓冲区后才进行实际I/O操作。对于驻留在磁盘上的文件通常是由标准I/O库实施全缓冲。一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需使用的缓冲区。
术语冲洗说明I/O缓冲区的写操作。缓冲区可由标准I/O例程自动冲洗，或者可以调用函数fflush冲洗一个流。值得引起注意的是在UNIX环境 中，flush有两种意思。在标准I/O库方面，flush意味着将缓冲区中的内容写到磁盘上。在终端驱动程序方面flush表示丢弃已存储在缓冲区中的数据。

填满标准I/O缓存区才进行实际的I/O操作。磁盘上的了件用标准I/O打开，默认都是全缓存的。当缓存区填满或者进行flush操作时候才会进行磁盘操作。


2、行缓冲。在这种情况下，当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。这允许我们一次输出一个字符，但只有在写了一行之后才进行实际I/O操作。当流涉及一个终端时，通常使用行缓冲。

当输入输出遇到换行符时候就是行缓存了。标准输入和标准输出都是行缓存。

对于行缓冲有两个限制。第一，因为标准I/O库用来收集每一行的缓冲区的长度是固定的，所以只要填满了缓冲区，那么即使没有写一个换行符，也进行I/O操 作。第二，任何时候只要通过标准I/O库要求从a一个布袋缓冲的流，或者b一个行缓冲的流得到输入数据，那么就会造成冲洗所有行缓冲输出流。在b中带了一 个在括号中的说明，其理由是，所需的数据可能已在缓冲区中，他并不需求在需要数据时才从内核读数据。很明显，从不带缓冲的一个流中进行输入要求当时从内核得到数据。

3、不带缓冲。标准I/O库不对字符进行缓冲存储。例如，如果用I/O函数fputs写15个字符到不带缓冲的流中，则该函数很可能用write系统调用函数将这些字符立即写至相关联的打开文件中。

标准出错流stderr通常是不带缓冲的，这就使得出错信息可以尽快显示出来，而不管它们是否含有一个换行符。

不对I/O操作进行缓存，对流的读写可以立即操作实际文件。

setvbuf(stdout,NULL,_IONBF,0);//调用setvbuf函数将缓存类型改为无缓存。

